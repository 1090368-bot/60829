<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D ç„¡ç›¡è·‘é…·</title>
    <!-- å¼•å…¥ Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- å¼•å…¥ Three.js å‡½å¼åº« -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* éŠæˆ²å°ˆç”¨æ¨£å¼ */
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            background-color: #1a1a1a;
            color: white;
        }
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        canvas {
            display: block;
        }
        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* è®“é»æ“Šäº‹ä»¶å¯ä»¥ç©¿é€åˆ° canvas */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 1rem;
            z-index: 10;
        }
        #message-box {
            pointer-events: auto;
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 2rem;
            background-color: rgba(31, 41, 55, 0.95); /* Gray-800 semi-transparent */
            border-radius: 12px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            text-align: center;
            max-width: 90%;
            border: 2px solid #6366f1; /* Indigo-500 */
        }
        /* Loading spinner for the buttons */
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #fff;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="ui-overlay">
            <!-- é ‚éƒ¨è³‡è¨Š -->
            <div class="flex justify-between items-start w-full">
                <div class="text-xl sm:text-2xl font-bold bg-gray-700/50 p-2 rounded-lg shadow-lg">
                    åˆ†æ•¸: <span id="score-display">0</span>
                </div>
                <div class="text-xl sm:text-2xl font-bold bg-gray-700/50 p-2 rounded-lg shadow-lg">
                    æœ€é«˜åˆ†: <span id="high-score-display">0</span>
                </div>
            </div>

            <!-- åº•éƒ¨æ“ä½œæç¤º (å·²æ›´æ–°è·³èºæŒ‡ä»¤) -->
            <div class="text-center bg-gray-700/50 p-2 rounded-lg shadow-lg max-w-lg mx-auto">
                <p class="text-sm sm:text-base">
                    æ§åˆ¶: &nbsp;
                    <span class="font-mono bg-indigo-500 px-2 py-1 rounded">â†</span> / <span class="font-mono bg-indigo-500 px-2 py-1 rounded">A</span> (å·¦ç§») &nbsp;|&nbsp;
                    <span class="font-mono bg-indigo-500 px-2 py-1 rounded">â†’</span> / <span class="font-mono bg-indigo-500 px-2 py-1 rounded">D</span> (å³ç§») &nbsp;|&nbsp;
                    <span class="font-mono bg-pink-500 px-2 py-1 rounded">â†‘</span> / <span class="font-mono bg-pink-500 px-2 py-1 rounded">W</span> / <span class="font-mono bg-pink-500 px-2 py-1 rounded">Space</span> (è·³èº)
                </p>
                <p class="text-xs sm:text-sm mt-1">
                    è§¸æ§: é»æ“Šè¢å¹•å·¦/å³åŠé‚Šç§»å‹• (å°šä¸æ”¯æ´è§¸æ§è·³èº)
                </p>
            </div>
        </div>

        <!-- éŠæˆ²è¨Šæ¯æ¡† (Game Over/Start) -->
        <div id="message-box">
            <h2 id="message-title" class="text-3xl font-extrabold mb-4 text-indigo-400">3D ç„¡ç›¡è·‘é…·</h2>
            <p id="message-text" class="text-lg mb-6">
                æº–å‚™å¥½äº†å—ï¼Ÿé»æ“Šé–‹å§‹éŠæˆ²ï¼
            </p>

            <!-- æŒ‘æˆ°å»ºè­°å€å¡Š (Gemini API Features) -->
            <div id="challenge-area" class="mt-4 pt-4 border-t border-gray-600 hidden">
                
                <!-- æŒ‘æˆ°å»ºè­°é¡¯ç¤º -->
                <p id="challenge-suggestion" class="text-sm italic text-gray-300 mb-2 break-words text-left hidden"></p>
                
                <!-- æŒ‘æˆ°å»ºè­°æŒ‰éˆ• -->
                <button id="gemini-challenge-button" class="w-full px-4 py-2 bg-purple-600 hover:bg-purple-500 text-white font-bold rounded-full transition duration-150 ease-in-out shadow-lg transform hover:scale-105 text-sm flex items-center justify-center mb-4">
                    âœ¨ ç²å–ä¸‹æ¬¡æŒ‘æˆ° âœ¨
                </button>

                <!-- è¡¨ç¾åˆ†æé¡¯ç¤º -->
                <p id="analysis-feedback" class="text-sm italic text-yellow-300 mb-2 break-words text-left hidden"></p>
                
                <!-- è¡¨ç¾åˆ†ææŒ‰éˆ• -->
                <button id="gemini-analysis-button" class="w-full px-4 py-2 bg-green-600 hover:bg-green-500 text-white font-bold rounded-full transition duration-150 ease-in-out shadow-lg transform hover:scale-105 text-sm flex items-center justify-center mb-4">
                    ğŸŒŸ ç²å–è¡¨ç¾åˆ†æèˆ‡å»ºè­° ğŸŒŸ
                </button>
                
                <!-- å‹•æ…‹è·‘é…·æŠ€å·§å€å¡Š -->
                <div id="dynamic-tip-area" class="p-2 rounded bg-gray-700/50">
                    <p class="text-xs font-bold text-indigo-400 mb-1">ğŸ’¡ è·‘é…·æŠ€å·§ï¼š</p>
                    <div id="tip-loading" class="flex items-center justify-center text-sm text-gray-400 py-1 hidden">
                        <div class="spinner w-4 h-4 mr-2"></div> æ­£åœ¨ç²å–å¯¦ç”¨æŠ€å·§...
                    </div>
                    <p id="dynamic-tip-text" class="text-sm italic text-gray-300 break-words text-left hidden"></p>
                    <p id="tip-source" class="text-xs text-blue-400 mt-2 text-left hidden"></p>
                </div>
            </div>

            <button id="start-button" class="mt-4 px-6 py-3 bg-indigo-600 hover:bg-indigo-500 text-white font-bold rounded-full transition duration-150 ease-in-out shadow-lg transform hover:scale-105">
                é–‹å§‹éŠæˆ²
            </button>
        </div>
    </div>

    <script type="module">
        // ------------------ FIREBASE SETUP (MANDATORY) ------------------
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Global variables provided by the canvas environment
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        let db, auth, userId;
        let isFirebaseReady = false;

        if (firebaseConfig) {
            try {
                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                async function authenticate() {
                    if (initialAuthToken) {
                        await signInWithCustomToken(auth, initialAuthToken);
                    } else {
                        await signInAnonymously(auth);
                    }
                    userId = auth.currentUser?.uid || crypto.randomUUID();
                    isFirebaseReady = true;
                    console.log("Firebase Auth Ready. User ID:", userId);
                    loadHighScore();
                }
                authenticate();
            } catch (error) {
                console.error("Firebase initialization failed:", error);
            }
        } else {
            console.warn("Firebase config missing. High score will not be saved persistently.");
            // Fallback for high score storage if Firebase is unavailable
            window.localStorageHighScore = 0;
            isFirebaseReady = true; // Proceed with game logic
        }

        // Firestore paths
        const getHighScoreDocRef = () => {
            if (!db || !userId) return null;
            // Private data path: /artifacts/{appId}/users/{userId}/game_data/runner_game
            return doc(db, 'artifacts', appId, 'users', userId, 'game_data', 'runner_game');
        };

        // ------------------ GAME VARIABLES & CONSTANTS ------------------

        // Three.js elements
        let scene, camera, renderer;
        let player, ground, light, obstacles = [];

        // Game state
        let gameState = 'loading'; // 'loading', 'ready', 'playing', 'gameOver'
        let score = 0;
        let highScore = 0;
        let obstacleSpeed = 0.16;
        const speedIncrement = 0.00005;
        const maxObstacleSpeed = 0.30;
        let lastObstacleTime = 0;
        const obstacleInterval = 1000;

        // Player physics
        const laneXPositions = [-3, 0, 3];
        let currentLane = 1; // 0 (Left), 1 (Center), 2 (Right)
        let isMovingHorizontal = false;
        const moveDuration = 100; // ms for lane switch
        let moveStartTime = 0;
        let startX = 0;
        let targetX = 0;

        // NEW: Jump and Gravity Physics
        const playerBaseY = 0.75; // The center Y position when standing on the ground (since box height is 1.5)
        let isJumping = false;
        let playerVelocityY = 0;
        const gravity = -0.005; 
        const jumpVelocity = 0.15; // Initial upward velocity for jump

        // HTML elements
        const scoreDisplay = document.getElementById('score-display');
        const highScoreDisplay = document.getElementById('high-score-display');
        const messageBox = document.getElementById('message-box');
        const messageTitle = document.getElementById('message-title');
        const messageText = document.getElementById('message-text');
        const startButton = document.getElementById('start-button');
        const gameContainer = document.getElementById('game-container');
        
        // Gemini elements
        const challengeArea = document.getElementById('challenge-area');
        const geminiChallengeButton = document.getElementById('gemini-challenge-button');
        const challengeSuggestion = document.getElementById('challenge-suggestion');
        const geminiAnalysisButton = document.getElementById('gemini-analysis-button');
        const analysisFeedback = document.getElementById('analysis-feedback');
        const dynamicTipText = document.getElementById('dynamic-tip-text');
        const tipSource = document.getElementById('tip-source');
        const tipLoading = document.getElementById('tip-loading');


        // ------------------ FIREBASE HIGH SCORE FUNCTIONS ------------------

        async function loadHighScore() {
            if (!isFirebaseReady) {
                // Load from localStorage fallback
                highScore = parseInt(localStorage.getItem('runnerHighScore') || '0', 10);
                highScoreDisplay.textContent = highScore.toString();
                gameState = 'ready';
                return;
            }

            try {
                const docRef = getHighScoreDocRef();
                if (docRef) {
                    const docSnap = await getDoc(docRef);
                    if (docSnap.exists()) {
                        highScore = docSnap.data().highScore || 0;
                    }
                    highScoreDisplay.textContent = highScore.toString();
                }
            } catch (error) {
                console.error("Error loading high score:", error);
            }
            gameState = 'ready';
        }

        async function saveHighScore(newScore) {
            if (newScore <= highScore) return;

            highScore = newScore;
            highScoreDisplay.textContent = highScore.toString();

            if (!isFirebaseReady) {
                // Save to localStorage fallback
                localStorage.setItem('runnerHighScore', newScore.toString());
                return;
            }

            try {
                const docRef = getHighScoreDocRef();
                if (docRef) {
                    await setDoc(docRef, { highScore: newScore }, { merge: true });
                    console.log("High score saved to Firestore:", newScore);
                }
            } catch (error) {
                console.error("Error saving high score:", error);
            }
        }


        // ------------------ GEMINI API INTEGRATION ------------------

        const API_KEY = ""; // Leave as empty string for Canvas environment
        const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${API_KEY}`;

        // Utility for exponential backoff retry and response parsing
        async function exponentialBackoffFetch(url, options, retries = 3) {
            for (let i = 0; i < retries; i++) {
                try {
                    const response = await fetch(url, options);
                    if (response.ok) {
                        const result = await response.json();
                        const candidate = result.candidates?.[0];

                        if (candidate && candidate.content?.parts?.[0]?.text) {
                            const text = candidate.content.parts[0].text;
                            
                            // Extract grounding sources
                            let sources = [];
                            const groundingMetadata = candidate.groundingMetadata;
                            if (groundingMetadata && groundingMetadata.groundingAttributions) {
                                sources = groundingMetadata.groundingAttributions
                                    .map(attribution => ({
                                        uri: attribution.web?.uri,
                                        title: attribution.web?.title,
                                    }))
                                    .filter(source => source.uri && source.title); 
                            }

                            return { text, sources };

                        } else {
                             throw new Error('Invalid response structure or missing text content.');
                        }
                    }
                } catch (error) {
                    if (i === retries - 1) throw error;
                    const delay = Math.pow(2, i) * 1000 + Math.random() * 1000;
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
            throw new Error('All fetch retries failed.');
        }

        // --- Feature 1: Challenge Suggestion ---
        async function generateChallenge(currentScore) {
            const systemPrompt = `ä½ æ˜¯ä¸€å€‹å……æ»¿å‰µæ„çš„éŠæˆ²è¨­è¨ˆå¸«ï¼Œå°ˆé–€ç‚ºç„¡ç›¡è·‘é…·éŠæˆ²è¨­è¨ˆæŒ‘æˆ°ã€‚æ ¹æ“šç©å®¶çš„åˆ†æ•¸ï¼Œç‚ºä»–å€‘ä¸‹ä¸€æ¬¡çš„éŠæˆ²æä¾›ä¸€å€‹ç°¡çŸ­ä¸”æœ‰è¶£ã€é›£åº¦é©ä¸­çš„è‡ªè¨‚æŒ‘æˆ°ã€‚é™åˆ¶åœ¨ 30 å€‹ä¸­æ–‡å­—ä»¥å…§ã€‚è«‹ä½¿ç”¨ä¸­æ–‡ï¼ˆç¹é«”ï¼‰ã€‚`;

            const userQuery = `ç©å®¶å‰›å‰›ç²å¾—äº† ${currentScore} åˆ†ã€‚è«‹ç‚ºä»–ä¸‹ä¸€æ¬¡çš„éŠæˆ²è¨­è¨ˆä¸€å€‹å‰µæ„æŒ‘æˆ°ã€‚`;

            const payload = {
                contents: [{ parts: [{ text: userQuery }] }],
                systemInstruction: { parts: [{ text: systemPrompt }] },
            };

            geminiChallengeButton.innerHTML = '<div class="spinner"></div> æ­£åœ¨ç”ŸæˆæŒ‘æˆ°...';
            geminiChallengeButton.disabled = true;
            challengeSuggestion.textContent = '';
            challengeSuggestion.classList.add('hidden');

            try {
                const result = await exponentialBackoffFetch(API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                challengeSuggestion.textContent = 'âœ¨ ä½ çš„æ–°æŒ‘æˆ°: ' + result.text.trim();
                challengeSuggestion.classList.remove('hidden');

            } catch (error) {
                challengeSuggestion.textContent = 'ç”ŸæˆæŒ‘æˆ°å¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦ã€‚';
                challengeSuggestion.classList.remove('hidden');
                console.error("Gemini API Error (Challenge):", error);
            } finally {
                geminiChallengeButton.innerHTML = 'âœ¨ ç²å–ä¸‹æ¬¡æŒ‘æˆ° âœ¨';
                geminiChallengeButton.disabled = false;
            }
        }

        // --- Feature 2: Gameplay Analysis ---
        async function analyzeGameplay(currentScore, highScore) {
            const systemPrompt = `ä½ æ˜¯ä¸€ä½å°ˆæ¥­ä¸”é¼“èˆäººå¿ƒçš„éŠæˆ²æ•™ç·´ã€‚ä½ çš„ä»»å‹™æ˜¯åˆ†æç©å®¶çš„éŠæˆ²æ•¸æ“šï¼ˆç•¶å‰åˆ†æ•¸å’Œæœ€é«˜åˆ†ï¼‰ï¼Œæä¾›ç°¡çŸ­çš„å€‹äººåŒ–å›é¥‹ï¼Œä¸¦çµ¦å‡ºä¸€å€‹å…·é«”çš„ã€å¯å¯¦è¸çš„ç­–ç•¥å»ºè­°ï¼Œå¹«åŠ©ç©å®¶æå‡è¡¨ç¾ã€‚ä½ çš„å›æ‡‰æ‡‰ç°¡æ½”ã€é¼“èˆäººå¿ƒï¼Œä¸¦ä»¥ä¸­æ–‡ï¼ˆç¹é«”ï¼‰å‘ˆç¾ã€‚é™åˆ¶åœ¨ 50 å€‹ä¸­æ–‡å­—ä»¥å…§ã€‚`;

            const scoreDiff = highScore - currentScore;
            let queryContext;

            if (currentScore >= highScore && highScore > 0) {
                queryContext = `ç©å®¶å‰›æ‰“ç ´äº†è‡ªå·±çš„æœ€é«˜åˆ† ${highScore}ï¼Œå–å¾—äº† ${currentScore} åˆ†ï¼è«‹çµ¦äºˆæ¥µå¤§çš„è®šæšä¸¦é¼“å‹µä»–å€‘è¨­å®šä¸‹ä¸€å€‹æ›´é«˜çš„ç›®æ¨™ã€‚`;
            } else if (currentScore > 0 && scoreDiff <= 10) {
                queryContext = `ç©å®¶çš„åˆ†æ•¸ ${currentScore} èˆ‡ä»–å€‘çš„æœ€é«˜åˆ† ${highScore} å·®è·ä¸åˆ° 10 åˆ†ã€‚è«‹æä¾›é‡å°æ€§çš„å¾®èª¿å»ºè­°ã€‚`;
            } else if (currentScore === 0) {
                queryContext = `ç©å®¶å¾—åˆ†ç‚º 0ã€‚é€™å¯èƒ½æ˜¯ä¸€æ¬¡å¿«é€Ÿçš„å¤±æ•—ã€‚è«‹æä¾›ä¸€å€‹ç©æ¥µçš„èµ·æ­¥å»ºè­°ã€‚`;
            } else {
                queryContext = `ç©å®¶çš„åˆ†æ•¸ç‚º ${currentScore}ï¼Œè€Œä»–å€‘çš„æœ€é«˜åˆ†ç‚º ${highScore}ã€‚è«‹çµ¦äºˆé¼“å‹µå’Œä¸€å€‹é€šç”¨çš„é€²æ­¥ç­–ç•¥ã€‚`;
            }

            const userQuery = `æ•¸æ“šåˆ†æï¼š${queryContext}`;

            const payload = {
                contents: [{ parts: [{ text: userQuery }] }],
                systemInstruction: { parts: [{ text: systemPrompt }] },
            };

            geminiAnalysisButton.innerHTML = '<div class="spinner"></div> æ­£åœ¨åˆ†æ...';
            geminiAnalysisButton.disabled = true;
            analysisFeedback.textContent = '';
            analysisFeedback.classList.add('hidden');

            try {
                const result = await exponentialBackoffFetch(API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                analysisFeedback.textContent = 'ğŸŒŸ æ•™ç·´å›é¥‹: ' + result.text.trim();
                analysisFeedback.classList.remove('hidden');

            } catch (error) {
                analysisFeedback.textContent = 'è¡¨ç¾åˆ†æå¤±æ•—ï¼Œè«‹æª¢æŸ¥ç¶²è·¯é€£æ¥ã€‚';
                analysisFeedback.classList.remove('hidden');
                console.error("Gemini API Error (Analysis):", error);
            } finally {
                geminiAnalysisButton.innerHTML = 'ğŸŒŸ ç²å–è¡¨ç¾åˆ†æèˆ‡å»ºè­° ğŸŒŸ';
                geminiAnalysisButton.disabled = false;
            }
        }
        
        // --- Feature 3: Dynamic Runner Tip (New, uses grounding) ---
        async function fetchDynamicTip(currentScore) {
            
            const systemPrompt = `ä½ æ˜¯ä¸€ä½æ™ºæ…§çš„è·‘é…·è¼”åŠ©ç³»çµ±ã€‚è«‹ç‚ºé€™å ´ç„¡ç›¡è·‘é…·éŠæˆ²æä¾›ä¸€å€‹ç°¡çŸ­ï¼ˆç´„ 20 å­—ï¼‰ï¼Œä¸”èˆ‡å°ˆæ³¨åŠ›ã€åæ‡‰é€Ÿåº¦æˆ–æµæš¢ç§»å‹•ç›¸é—œçš„å¯¦ç”¨æŠ€å·§ã€‚è«‹ç¢ºä¿ä½ çš„å›ç­”æ˜¯åŸºæ–¼çœŸå¯¦ä¸–ç•Œçš„çŸ¥è­˜æˆ–å»ºè­°ï¼Œä¸¦ä½¿ç”¨ä¸­æ–‡ï¼ˆç¹é«”ï¼‰ã€‚`;

            const userQuery = `è«‹æä¾›ä¸€å€‹é©ç”¨æ–¼ç„¡ç›¡è·‘é…·éŠæˆ²çš„ç°¡çŸ­æŠ€å·§ã€‚ç©å®¶å‰›ç²å¾—åˆ†æ•¸ï¼š${currentScore}ã€‚`;

            const payload = {
                contents: [{ parts: [{ text: userQuery }] }],
                tools: [{ "google_search": {} }], // Enable Google Search grounding
                systemInstruction: { parts: [{ text: systemPrompt }] },
            };

            dynamicTipText.classList.add('hidden');
            tipSource.classList.add('hidden');
            tipLoading.classList.remove('hidden');

            try {
                const result = await exponentialBackoffFetch(API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                
                dynamicTipText.textContent = result.text.trim();
                dynamicTipText.classList.remove('hidden');
                
                // Display source if available
                if (result.sources && result.sources.length > 0) {
                    const sourceTitle = result.sources[0].title;
                    tipSource.innerHTML = `<a href="${result.sources[0].uri}" target="_blank" class="hover:underline">${sourceTitle}</a>`;
                    tipSource.classList.remove('hidden');
                }

            } catch (error) {
                dynamicTipText.textContent = 'ç²å–æŠ€å·§å¤±æ•—ã€‚';
                dynamicTipText.classList.remove('hidden');
                console.error("Gemini API Error (Tip):", error);
            } finally {
                tipLoading.classList.add('hidden');
            }
        }


        // ------------------ THREE.JS INITIALIZATION ------------------

        function init() {
            // 1. Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a); // Dark background

            // 2. Camera setup
            const aspect = window.innerWidth / window.innerHeight;
            camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000);
            camera.position.set(0, 5, 10);
            camera.lookAt(0, 0, 0);

            // 3. Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            gameContainer.appendChild(renderer.domElement);

            // 4. Lighting
            light = new THREE.DirectionalLight(0xffffff, 1.5);
            light.position.set(5, 10, 7.5);
            light.castShadow = true;
            scene.add(light);

            const ambientLight = new THREE.AmbientLight(0x404040, 2);
            scene.add(ambientLight);

            // 5. Player (The Runner)
            const playerGeometry = new THREE.BoxGeometry(1.5, 1.5, 1.5);
            const playerMaterial = new THREE.MeshLambertMaterial({ color: 0x6366f1 }); // Indigo
            player = new THREE.Mesh(playerGeometry, playerMaterial);
            player.position.set(laneXPositions[currentLane], playerBaseY, 5); // Start on the ground
            player.castShadow = true;
            player.receiveShadow = true;
            scene.add(player);

            // 6. Ground (The Runway)
            const groundGeometry = new THREE.PlaneGeometry(12, 500, 1, 1);
            const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x374151 }); // Dark Grey
            ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = 0;
            ground.position.z = -240; // Extend far into the distance
            ground.receiveShadow = true;
            scene.add(ground);

            // Set up shadows
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            // Event Listeners
            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('keydown', onKeyDown, false);
            gameContainer.addEventListener('touchstart', onTouchStart, false); // Touch for horizontal only
            startButton.addEventListener('click', startGame, false);
            
            // Attach event listeners for the Gemini buttons
            geminiChallengeButton.addEventListener('click', () => generateChallenge(score));
            geminiAnalysisButton.addEventListener('click', () => analyzeGameplay(score, highScore));

            showStartMessage();
            animate();
        }

        // ------------------ GAME CONTROL & LOGIC ------------------

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function jump() {
            // Only allow jumping if not currently in the air
            if (!isJumping) {
                isJumping = true;
                playerVelocityY = jumpVelocity;
            }
        }

        function onKeyDown(event) {
            if (gameState !== 'playing') return;

            switch (event.key) {
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    movePlayerHorizontal(-1);
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    movePlayerHorizontal(1);
                    break;
                case 'ArrowUp':
                case 'w':
                case 'W':
                case ' ': // Space bar for jump
                    jump();
                    break;
            }
        }

        function onTouchStart(event) {
            if (gameState !== 'playing') return;
            // Note: Touch only supports horizontal movement for simplicity
            const touchX = event.touches[0].clientX;
            const screenWidth = window.innerWidth;

            if (touchX < screenWidth / 2) {
                movePlayerHorizontal(-1); // Left side
            } else {
                movePlayerHorizontal(1); // Right side
            }
        }

        function movePlayerHorizontal(direction) {
            if (isMovingHorizontal) return;

            let newLane = currentLane + direction;

            if (newLane >= 0 && newLane < laneXPositions.length) {
                currentLane = newLane;
                isMovingHorizontal = true;
                moveStartTime = performance.now();
                startX = player.position.x;
                targetX = laneXPositions[currentLane];
            }
        }
        
        // Combines both horizontal lane switching and vertical jumping physics
        function updatePlayerPhysics(delta) {
            // --- 1. Horizontal Movement (Lane Switching) ---
            if (isMovingHorizontal) {
                const elapsedTime = performance.now() - moveStartTime;
                const progress = Math.min(1, elapsedTime / moveDuration);

                player.position.x = startX + (targetX - startX) * progress;

                if (progress >= 1) {
                    isMovingHorizontal = false;
                    player.position.x = targetX; // Snap to the target position
                }
            }
            
            // --- 2. Vertical Movement (Jump and Gravity) ---
            if (isJumping) {
                // Apply gravity to vertical velocity
                playerVelocityY += gravity * 60 * delta; // 60 is to scale the speed for better feeling
                
                // Update vertical position
                player.position.y += playerVelocityY * 60 * delta;
                
                // Check for landing
                if (player.position.y <= playerBaseY) {
                    player.position.y = playerBaseY;
                    isJumping = false;
                    playerVelocityY = 0;
                }
            }
        }

        function generateObstacle() {
            // Get a random lane index (0, 1, or 2)
            const laneIndex = Math.floor(Math.random() * laneXPositions.length);
            const obstacleX = laneXPositions[laneIndex];

            // Randomly choose size and depth
            const width = 1.5 + Math.random() * 1; // 1.5 to 2.5
            let height;
            
            // NEW: Randomly choose between a jumpable low obstacle or a dodgeable high obstacle
            if (Math.random() < 0.5) {
                // Low Obstacle (Jumpable): Height 0.8 to 1.3
                height = 0.8 + Math.random() * 0.5; 
            } else {
                // High Obstacle (Dodgeable): Height 3.0 to 4.5
                height = 3.0 + Math.random() * 1.5; 
            }
            
            const depth = 1.0 + Math.random() * 1.5; // 1.0 to 2.5

            const geometry = new THREE.BoxGeometry(width, height, depth);
            const material = new THREE.MeshLambertMaterial({ color: Math.random() * 0xffffff }); // Random color
            const obstacle = new THREE.Mesh(geometry, material);

            // Start position far down the track (negative Z)
            obstacle.position.set(obstacleX, height / 2, -100);
            obstacle.castShadow = true;
            obstacle.receiveShadow = true;

            scene.add(obstacle);
            obstacles.push(obstacle);
        }

        function updateObstacles(delta) {
            // Move obstacles towards the player (positive Z)
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obstacle = obstacles[i];
                obstacle.position.z += obstacleSpeed * 60 * delta * 1.5; // Scale speed for consistency

                // Check for removal (passed the player)
                if (obstacle.position.z > camera.position.z) {
                    scene.remove(obstacle);
                    obstacles.splice(i, 1);
                    // Increase score for passing
                    score++;
                    scoreDisplay.textContent = score;
                }
            }

            // Generate new obstacles
            const currentTime = performance.now();
            if (currentTime > lastObstacleTime + obstacleInterval) {
                generateObstacle();
                lastObstacleTime = currentTime;
            }

            // Increase difficulty
            obstacleSpeed = Math.min(maxObstacleSpeed, obstacleSpeed + speedIncrement);
        }

        function checkCollisions() {
            // Player dimensions are 1.5x1.5x1.5
            const playerHalfSize = 0.75;
            const playerPos = player.position;

            for (let i = 0; i < obstacles.length; i++) {
                const obstacle = obstacles[i];
                const box = new THREE.Box3().setFromObject(obstacle);

                // Player Bounding Box
                const playerMinX = playerPos.x - playerHalfSize;
                const playerMaxX = playerPos.x + playerHalfSize;
                const playerMinY = playerPos.y - playerHalfSize;
                const playerMaxY = playerPos.y + playerHalfSize;
                const playerMinZ = playerPos.z - playerHalfSize;
                const playerMaxZ = playerPos.z + playerHalfSize;

                // Obstacle Bounding Box
                const obstacleMinX = box.min.x;
                const obstacleMaxX = box.max.x;
                const obstacleMinY = box.min.y;
                const obstacleMaxY = box.max.y;
                const obstacleMinZ = box.min.z;
                const obstacleMaxZ = box.max.z;

                // Collision check (overlap on all three axes)
                const zOverlap = playerMinZ < obstacleMaxZ && playerMaxZ > obstacleMinZ;
                const xOverlap = playerMinX < obstacleMaxX && playerMaxX > obstacleMinX;
                const yOverlap = playerMinY < obstacleMaxY && playerMaxY > obstacleMinY;

                if (zOverlap && xOverlap && yOverlap) {
                    gameOver();
                    return;
                }
            }
        }


        // ------------------ GAME LIFECYCLE ------------------

        function resetGame() {
            // Clear all obstacles
            obstacles.forEach(obstacle => scene.remove(obstacle));
            obstacles = [];

            // Reset player position and physics
            currentLane = 1;
            player.position.set(laneXPositions[currentLane], playerBaseY, 5);
            isMovingHorizontal = false;
            isJumping = false;
            playerVelocityY = 0;

            // Reset score and difficulty
            score = 0;
            scoreDisplay.textContent = '0';
            obstacleSpeed = 0.16;
            lastObstacleTime = 0;

            // Hide and clear all Gemini feature displays
            challengeArea.classList.add('hidden');
            
            challengeSuggestion.classList.add('hidden');
            challengeSuggestion.textContent = '';
            
            analysisFeedback.classList.add('hidden');
            analysisFeedback.textContent = '';
            
            dynamicTipText.classList.add('hidden');
            dynamicTipText.textContent = '';
            tipSource.classList.add('hidden');
            tipSource.innerHTML = '';
            tipLoading.classList.add('hidden');
        }

        function startGame() {
            if (gameState === 'playing') return;

            resetGame();
            gameState = 'playing';
            messageBox.style.display = 'none';
        }

        function gameOver() {
            gameState = 'gameOver';

            saveHighScore(score);
            
            // --- Trigger Dynamic Tip on Game Over ---
            fetchDynamicTip(score);

            messageTitle.textContent = 'éŠæˆ²çµæŸï¼';
            messageText.innerHTML = `
                <p class="text-xl font-bold mb-2">ä½ çš„åˆ†æ•¸ï¼š${score}</p>
                <p class="text-lg">æœ€é«˜åˆ†ï¼š${highScore}</p>
                <p class="mt-4">çœ‹çœ‹æ‚¨èƒ½å¾ AI æ•™ç·´å’Œè·‘é…·æŠ€å·§ä¸­å­¸åˆ°ä»€éº¼ï¼</p>
            `;
            startButton.textContent = 'é‡æ–°é–‹å§‹';
            messageBox.style.display = 'flex';
            challengeArea.classList.remove('hidden'); // Show challenge area
        }

        function showStartMessage() {
            messageTitle.textContent = '3D ç„¡ç›¡è·‘é…·';
            messageText.innerHTML = `
                <p class="text-lg mb-2">åœ¨è³½é“ä¸Šå·¦å³ç§»å‹•ï¼Œèº²é¿æ–¹å¡Šï¼</p>
                <p class="text-sm text-gray-400">
                    ç¾åœ¨æ‚¨å¯ä»¥æŒ‰ **W / â†‘ / Space** é€²è¡Œè·³èºä¾†è·¨è¶Šä½çŸ®éšœç¤™ç‰©ã€‚
                </p>
            `;
            startButton.textContent = 'é–‹å§‹éŠæˆ²';
            messageBox.style.display = 'flex';
        }

        // ------------------ ANIMATION LOOP ------------------

        let previousTime = 0;
        function animate(currentTime) {
            requestAnimationFrame(animate);

            if (gameState === 'playing') {
                // Calculate delta time
                const delta = (currentTime - previousTime) / 1000;
                previousTime = currentTime;

                // Update player movement (horizontal lane switching and vertical jump/gravity)
                updatePlayerPhysics(delta);

                // Update obstacles and increase speed
                updateObstacles(delta);

                // Check for collisions
                checkCollisions();

                // Simple spinning effect for the player for visual flair
                player.rotation.y += 0.01;
            } else {
                previousTime = currentTime; // Reset time if game is paused/over
            }

            renderer.render(scene, camera);
        }

        // Initialize the game when the window loads
        window.onload = function() {
            init();
        }

    </script>
</body>
</html>